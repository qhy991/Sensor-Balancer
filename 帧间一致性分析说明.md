# 帧间一致性分析说明

## 概述

帧间一致性分析专门针对传感器在连续帧之间的数据不一致性问题。当同样的物体按压同一个位置时，如果上一帧和下一帧的数据差异过大，就会影响测量的稳定性和可靠性。

## 问题描述

### 帧间不一致的表现
1. **数值波动**：相同压力下，连续帧的数值不一致
2. **位置偏移**：压力中心位置在不同帧间发生偏移
3. **响应延迟**：传感器响应时间不一致
4. **噪声干扰**：随机噪声导致帧间差异

### 常见原因
- 传感器硬件噪声
- 信号处理电路不稳定
- 环境干扰（温度、湿度、电磁干扰）
- 机械振动
- 电源波动

## 分析方法

### 1. 帧间差异分析

#### 绝对差异
```python
abs_diff = np.abs(current_frame - previous_frame)
mean_abs_diff = np.mean(abs_diff)
max_abs_diff = np.max(abs_diff)
```

#### 相对差异
```python
relative_diff = abs_diff / previous_frame  # 避免除零
mean_rel_diff = np.mean(relative_diff)
```

### 2. 稳定性指标

#### 变异系数（CV）
```python
cv = std_deviation / mean_value
```
- CV < 0.05：非常稳定
- CV < 0.1：稳定
- CV < 0.2：一般
- CV > 0.2：不稳定

#### 稳定性评分
```python
stability_score = max(0, 1 - cv)
```

### 3. 异常帧检测

#### 3σ法则
```python
anomaly_threshold = mean_diff + 3 * std_diff
if current_diff > anomaly_threshold:
    # 检测到异常帧
```

#### 滑动窗口检测
```python
window_size = 5
for i in range(window_size, len(frames)):
    window_mean = np.mean(frames[i-window_size:i])
    if abs(frames[i] - window_mean) > threshold:
        # 检测到异常
```

### 4. 噪声特性分析

#### 噪声功率
```python
noise_power = np.var(time_series)
```

#### 频率特性
```python
fft_result = np.fft.fft(time_series)
power_spectrum = np.abs(fft_result)**2
main_frequency = np.argmax(power_spectrum[1:len(power_spectrum)//2]) + 1
```

## 一致性评分系统

### 评分标准（0-10分）

1. **帧间差异评分（40%）**
   - 平均差异 < 0.0001：4分
   - 平均差异 < 0.0005：3分
   - 平均差异 < 0.001：2分
   - 平均差异 < 0.002：1分
   - 平均差异 ≥ 0.002：0分

2. **稳定性评分（30%）**
   - 平均稳定性 > 0.9：3分
   - 平均稳定性 > 0.8：2.5分
   - 平均稳定性 > 0.7：2分
   - 平均稳定性 > 0.6：1.5分
   - 平均稳定性 > 0.5：1分
   - 平均稳定性 ≤ 0.5：0分

3. **噪声评分（20%）**
   - 平均噪声功率 < 0.000001：2分
   - 平均噪声功率 < 0.00001：1.5分
   - 平均噪声功率 < 0.0001：1分
   - 平均噪声功率 < 0.001：0.5分
   - 平均噪声功率 ≥ 0.001：0分

4. **异常帧惩罚（10%）**
   - 无异常帧：1分
   - 1-2个异常帧：0.8分
   - 3-5个异常帧：0.6分
   - 6-10个异常帧：0.4分
   - >10个异常帧：0分

### 评估等级
- **8-10分**：优秀 ✅
- **6-8分**：良好 ✅
- **4-6分**：一般 ⚠️
- **0-4分**：较差 ❌

## 校正方法

### 1. 指数平滑校正

```python
def exponential_smoothing(current_frame, previous_frame, alpha=0.7):
    """
    指数平滑校正
    
    Args:
        current_frame: 当前帧
        previous_frame: 前一帧
        alpha: 平滑因子 (0-1)
    
    Returns:
        校正后的帧
    """
    corrected_frame = alpha * previous_frame + (1 - alpha) * current_frame
    return corrected_frame
```

### 2. 阈值校正

```python
def threshold_correction(current_frame, previous_frame, threshold=0.001):
    """
    阈值校正
    
    Args:
        current_frame: 当前帧
        previous_frame: 前一帧
        threshold: 校正阈值
    
    Returns:
        校正后的帧
    """
    frame_diff = np.abs(current_frame - previous_frame)
    
    if np.mean(frame_diff) > threshold:
        # 差异过大，进行校正
        corrected_frame = (previous_frame + current_frame) / 2
    else:
        # 差异在可接受范围内
        corrected_frame = current_frame
    
    return corrected_frame
```

### 3. 中值滤波校正

```python
def median_filter_correction(frame_history, window_size=3):
    """
    中值滤波校正
    
    Args:
        frame_history: 历史帧列表
        window_size: 窗口大小
    
    Returns:
        校正后的帧
    """
    if len(frame_history) < window_size:
        return frame_history[-1]
    
    # 对每个传感器点应用中值滤波
    height, width = frame_history[0].shape
    corrected_frame = np.zeros((height, width))
    
    for i in range(height):
        for j in range(width):
            values = [frame[i, j] for frame in frame_history[-window_size:]]
            corrected_frame[i, j] = np.median(values)
    
    return corrected_frame
```

### 4. 自适应校正

```python
def adaptive_correction(current_frame, previous_frame, learning_rate=0.1):
    """
    自适应校正
    
    Args:
        current_frame: 当前帧
        previous_frame: 前一帧
        learning_rate: 学习率
    
    Returns:
        校正后的帧
    """
    # 计算当前误差
    error = current_frame - previous_frame
    
    # 自适应调整
    correction = learning_rate * error
    
    # 应用校正
    corrected_frame = current_frame - correction
    
    return corrected_frame
```

## 使用指南

### 1. 实时监测

```python
# 开始帧间一致性监测
frame_analyzer = FrameConsistencyAnalyzer()

# 在数据更新循环中
def update_data():
    current_data = get_sensor_data()
    frame_analyzer.add_frame(current_data)
    
    # 实时计算一致性评分
    if len(frame_analyzer.frame_history) > 1:
        consistency_score = frame_analyzer._calculate_consistency_score()
        print(f"一致性评分: {consistency_score:.2f}/10")
```

### 2. 定期分析

```python
# 定期执行完整分析
def periodic_analysis():
    results = frame_analyzer.analyze_frame_consistency()
    
    # 检查一致性状态
    consistency_score = results.get('consistency_score', 0)
    if consistency_score < 6.0:
        print("警告：帧间一致性较差，建议检查传感器")
    
    # 保存分析结果
    save_analysis_results(results)
```

### 3. 自动校正

```python
# 启用帧间校正
correction_system = FrameCorrectionSystem()
correction_system.enable_correction(True)
correction_system.set_smoothing_factor(0.7)
correction_system.set_correction_threshold(0.001)

# 在数据处理中应用校正
def process_frame(raw_data):
    corrected_data = correction_system.correct_frame(raw_data)
    return corrected_data
```

## 改进建议

### 1. 硬件改进
- **传感器选择**：选择噪声更低的传感器
- **信号调理**：改善信号调理电路
- **屏蔽设计**：加强电磁屏蔽
- **电源稳定**：使用更稳定的电源

### 2. 软件改进
- **滤波算法**：实现更先进的滤波算法
- **自适应校正**：根据环境变化自适应调整参数
- **异常处理**：完善异常检测和处理机制
- **数据验证**：增加数据有效性验证

### 3. 环境控制
- **温度控制**：保持恒温环境
- **湿度控制**：控制环境湿度
- **振动隔离**：减少机械振动
- **电磁环境**：改善电磁环境

## 总结

帧间一致性分析是确保传感器测量稳定性的重要手段。通过系统性的分析和校正，可以显著提高传感器的测量精度和可靠性。关键是要：

1. **实时监测**：持续监控帧间一致性状态
2. **及时校正**：发现问题及时进行校正
3. **持续改进**：根据分析结果持续改进系统
4. **预防为主**：通过预防性措施减少不一致性

通过合理应用这些分析方法和校正手段，可以有效解决帧间不一致性问题，提高系统整体性能。 